# План интеграции Redis в Quoridor

Этот план описывает процесс перехода от хранения состояния игр в оперативной памяти сервера Node.js к использованию Redis. Это позволит сохранять матчи при перезапуске сервера и подготовит проект к горизонтальному масштабированию.

## 1. Подготовка окружения (Windows без Docker)

### Вариант А: WSL2 (Выбор профессионалов)
Это запуск полноценного Linux внутри Windows. Самый стабильный способ.
1. Откройте PowerShell от имени администратора и введите: `wsl --install`.
2. После перезагрузки установите Ubuntu из Microsoft Store.
3. В терминале Ubuntu введите:
   ```bash
   sudo apt update
   sudo apt install redis-server
   sudo service redis-server start
   ```
4. Теперь Redis доступен на `localhost:6379` в Windows.

### Вариант Б: Memurai (Самый быстрый запуск)
Redis-совместимый движок специально для Windows.
1. Скачайте инсталлятор с [memurai.com](https://www.memurai.com/).
2. Установите и запустите. Он будет работать как системная служба.

### Установка зависимостей
```bash
npm install redis
```

---

## 2. Архитектура хранилища (Key Schema)

Мы будем использовать следующие типы ключей в Redis:

| Ключ | Тип | Описание |
| :--- | :--- | :--- |
| `game:{id}` | **JSON / Hash** | Состояние активной игры (board, players, timers). |
| `room:{code}` | **JSON / Hash** | Данные приватной комнаты ожидания. |
| `queue:{tc}` | **List** | Очередь игроков для конкретного контроля времени. |
| `elo:leaderboard`| **Sorted Set** | Рейтинг игроков (Score = Elo, Member = PlayerID). |
| `session:{id}` | **String** | Токены авторизации с коротким TTL. |
| `token:game:{token}` | **String** | Маппинг токена игрока в ID активной игры (для Rejoin). |
| `global:lobby_id` | **String** | Инкрементальный счетчик для генерации ID лобби. |
| `limits:{ip/id}` | **String** | Счетчик для Rate Limiting с TTL. |

---

## 3. Этапы реализации

### Шаг 1: Redis Wrapper (`server/redis.js`)
Создать модуль для инициализации клиента Redis с обработкой ошибок и базовыми методами `getGame`/`saveGame`.

### Шаг 2: Миграция Matchmaking
- Заменить `searchQueues` на Redis `LPUSH` и `RPOP`.
- Использовать `INCR global:lobby_id` вместо локальной переменной `lobbyCounter`.

### Шаг 3: Состояние игровых сессий
- При создании игры сохранять состояние в `game:{id}`.
- В обработчике `playerMove`:
  1. `READ` состояние из Redis.
  2. Проверить валидность хода.
  3. `WRITE` обновленное состояние обратно.
- Установить **TTL (Time To Live)** для игр (например, 2 часа), чтобы они автоматически удалялись при заброшенности.

### Шаг 4: Система Rejoin
- Сохранять маппинг `token -> lobbyId` в Redis. Это позволит игроку вернуться в ту же игру даже после перезагрузки Node.js сервера.

---

## 4. Гайд по пошаговому запуску

1. **Запустите Redis**: Убедитесь, что `redis-cli ping` возвращает `PONG`.
2. **Конфигурация**: Создайте `.env` файл (или константы) с URL базы: `REDIS_URL=redis://localhost:6379`.
3. **Рефакторинг**:
   - Замените `let activeGames = {}` на вызовы `redis.hGet/hSet`.
   - Замените `let privateRooms = {}` на `redis.setEx` (с TTL).
4. **Тестирование**: 
   - Начните игру.
   - **Убейте процесс Node.js** (`Ctrl+C`).
   - Запустите сервер снова.
   - Обновите страницу клиента — игра должна восстановиться (Rejoin).

---

## 5. Возможные риски и решения
- **Состояние Race Condition**: Если два игрока пошлют команды одновременно, второй может перезаписать изменения первого.
  - *Решение*: Использование транзакций Redis (`MULTI/EXEC`) или Luа-скриптов для атомарного обновления состояния.
- **Latency**: Обращение к Redis чуть медленнее, чем к RAM.
  - *Решение*: Для Quoridor (пошаговая игра) разница в 1-2мс незаметна.

## 6. Будущее: ЭЛО и Авторизация

### Рейтинг ЭЛО
Redis — идеальный инструмент для этого. В нем есть структура **Sorted Sets (ZSET)**. 
- Одна команда `ZADD elo:leaderboard 1500 "Player1"` добавляет игрока.
- `ZREVRANGE elo:leaderboard 0 9` мгновенно возвращает Топ-10 игроков.
- Это работает в тысячи раз быстрее, чем запросы `SELECT/ORDER BY` в обычных базах данных.

### Авторизация
- **Для Redis**: Идеально хранить сессии, кэш профилей и временные коды подтверждения.
- **Для постоянной базы (PostgreSQL/MongoDB)**: Лучше оставить постоянные данные (хеши паролей, дату регистрации, полную историю всех игр). 
- **Итог**: Redis выдержит огромную нагрузку на чтение/запись рейтинга и сессий, но для "главного архива" аккаунтов в будущем стоит добавить классическую БД.
